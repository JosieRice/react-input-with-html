{"version":3,"sources":["../../src/utils.tsx","../../src/index.tsx","App.tsx","index.tsx"],"names":["getCaretData","nodes","el","textNodeArr","treeWalker","document","NodeFilter","node","getAllTextnodes","n","position","setCaretPos","id","value","placeholder","modifierArr","disabled","spellCheck","onChange","onSubmit","onBlur","onKeyUp","onKeyDown","props","useState","inputWithHTML","setInputWithHTML","caretPos","useEffect","caretData","data","selection","window","range","placeCaret","inputDisplay","buildStyledString","str","emitChange","e","enter","caretOffset","selected","preCaretRange","getCaretPosition","mutableInput","clone","match","modifier","mutableModifier","arr","uniqueArr","Set","correctModifier","re","RegExp","v","style","display","margin","React","whiteSpace","overflow","contentEditable","onInput","dangerouslySetInnerHTML","__html","top","left","App","input","setInput","regexMatch","htmlMod","className","console","log","ReactDOM","render","getElementById"],"mappings":"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","file":"static/js/main.6d13e39f.chunk.js","sourcesContent":["// not sure what this is doing, but should probably sanitize javascript injection\nexport const normalizeHtml = (str: string): string => {\n  return str && str.replace(/&nbsp;|\\u202F|\\u00A0/g, ' ')\n}\n\n// getting current position of caret to set in state as a reference\nexport const getCaretPosition = (el: HTMLDivElement) => {\n  let caretOffset = 0\n\n  if (typeof window.getSelection !== 'undefined') {\n    const range = window.getSelection()?.getRangeAt(0)\n    const selected = range?.toString().length\n    const preCaretRange = range?.cloneRange()\n\n    // @ts-ignore\n    preCaretRange.selectNodeContents(el)\n    // @ts-ignore\n    preCaretRange.setEnd(range.endContainer, range.endOffset)\n    // @ts-ignore\n    caretOffset = preCaretRange.toString().length - selected\n  }\n\n  return caretOffset\n}\n\nexport const getAllTextnodes = (el: HTMLDivElement) => {\n  let node\n  const textNodeArr = []\n\n  const treeWalker = document.createTreeWalker(\n    el,\n    NodeFilter.SHOW_TEXT,\n    null,\n    false\n  )\n\n  while ((node = treeWalker.nextNode())) textNodeArr.push(node)\n\n  return textNodeArr\n}\n\nexport const getCaretData = (\n  el: HTMLDivElement,\n  position: number,\n  setCaretPos: (arg: number) => void\n) => {\n  let node\n\n  const nodes = getAllTextnodes(el)\n\n  for (var n = 0; n < nodes.length; n++) {\n    // @ts-ignore\n    if (position > nodes[n].nodeValue.length && nodes[n + 1]) {\n      // remove amount from the position, go to next node\n      // @ts-ignore\n      position -= nodes[n].nodeValue.length\n    } else {\n      node = nodes[n]\n      break\n    }\n  }\n\n  // resets node and position settings if all html input is cleared\n\n  if (!node) {\n    setCaretPos(-1)\n\n    return { node: node, position: -1 }\n  }\n\n  // gives current position\n\n  return { node: node, position: position }\n}\n\ntype NodeData = {\n  node: Node\n  position: number\n}\n\nexport const placeCaret = (data: NodeData) => {\n  const selection = window.getSelection()\n  const range = document.createRange()\n\n  // programatic html generation can throws off the caret pos.\n\n  // this protects against placing caret where it can't go\n\n  const canPlaceCaret =\n    selection &&\n    data &&\n    data.node &&\n    data.position >= 0 &&\n    data.node.nodeValue &&\n    data.node.nodeValue.length >= data.position\n\n  if (canPlaceCaret) {\n    range.setStart(data.node, data.position)\n\n    range.collapse(true)\n\n    if (selection) {\n      selection.removeAllRanges()\n      selection.addRange(range)\n    }\n  }\n}\n","/**\n * an input element that can display programatic html but only takes string input\n */\n\nimport { clone } from 'lodash'\nimport React, { useEffect, useState } from 'react'\nimport {\n  getCaretData,\n  getCaretPosition,\n  normalizeHtml,\n  placeCaret\n} from './utils'\n\ntype ModifierObj = {\n  regexMatch: RegExp\n  htmlMod: string | Function // if it's a function than it's matching many different strings possibly\n  match?: boolean\n}\n\ntype Props = {\n  id: string\n  value: string\n  placeholder: string\n  modifierArr: ModifierObj[]\n  onChange: (arg1: string) => void // your `setInput` string hook;\n  onSubmit?: Function\n  disabled?: boolean\n  className?: string\n  onBlur?: any\n  onKeyUp?: any\n  onKeyDown?: any\n  spellCheck?: boolean\n}\n\nconst HTMLInput = ({\n  id,\n  value,\n  placeholder,\n  modifierArr,\n  disabled = false,\n  spellCheck = true,\n  onChange,\n  onSubmit,\n  onBlur,\n  onKeyUp,\n  onKeyDown,\n  ...props\n}: Props) => {\n  const [inputWithHTML, setInputWithHTML] = useState('')\n  const [caretPos, setCaretPos] = useState(-1)\n\n  useEffect(() => {\n    const el = document.getElementById(id) as HTMLDivElement\n    const caretData = getCaretData(el, caretPos, setCaretPos)\n\n    // only place caret if there is somewhere for it to go\n    if (caretData.node) placeCaret(caretData)\n  }, [inputWithHTML])\n\n  useEffect(() => {\n    if (value) {\n      const inputDisplay = buildStyledString(value)\n      setInputWithHTML(inputDisplay)\n    } else if (!value) {\n      setInputWithHTML('')\n    }\n  }, [value])\n\n  const emitChange = (e: any) => {\n    // handle enter and call onSubmit if it was give\n    const enter = e.keyCode === 13\n    if (enter && onSubmit) {\n      e.preventDefault()\n      onSubmit()\n      return\n    }\n    if (enter) {\n      e.preventDefault()\n      return\n    }\n\n    const el = e.currentTarget\n    const position = getCaretPosition(el)\n\n    onChange(el.innerText)\n    setCaretPos(position)\n  }\n\n  const buildStyledString = (value: string): string => {\n    let mutableInput = clone(value)\n\n    // adds match true or false to modifierObj\n    const mutableModifier = modifierArr.map((modifier) => {\n      const match = modifier.regexMatch.test(value)\n      modifier.match = match\n      return modifier\n    })\n\n    // for each match, find every instance and run the modification\n    mutableModifier.forEach((modifier) => {\n      if (modifier.match) {\n        const arr = mutableInput?.match(modifier.regexMatch)\n        const uniqueArr = [...new Set(arr)]\n\n        const modifyAll = () => {\n          const value = uniqueArr?.forEach((v) => {\n            const correctModifier =\n              typeof modifier.htmlMod === 'string'\n                ? modifier.htmlMod\n                : modifier.htmlMod(v)\n\n            // function htmlMods can match many different strings and need special treatment\n            if (typeof modifier.htmlMod === 'function') {\n              const re = new RegExp(v, 'g')\n              mutableInput = mutableInput?.replace(re, correctModifier)\n            } else {\n              mutableInput = mutableInput?.replace(\n                modifier.regexMatch,\n                correctModifier\n              )\n            }\n          })\n          return value\n        }\n\n        modifyAll()\n      }\n    })\n\n    // clears out any new lines\n    const newLineRegex = /\\r?\\n|\\r/g\n    mutableInput.replace(newLineRegex, '')\n\n    return mutableInput\n  }\n\n  return (\n    <div style={{ position: 'relative', display: 'table', margin: '0 auto' }}>\n      <div\n        id={id}\n        // respects any spaces\n        style={{ whiteSpace: 'pre', overflow: 'hidden' }}\n        contentEditable={!disabled}\n        onInput={emitChange}\n        onBlur={onBlur || emitChange}\n        onKeyUp={onKeyUp || emitChange}\n        onKeyDown={onKeyDown || emitChange}\n        dangerouslySetInnerHTML={{ __html: normalizeHtml(inputWithHTML) }}\n        spellCheck={spellCheck}\n        {...props}\n      />\n      {placeholder && !value && (\n        <div\n          style={{ position: 'absolute', top: 0, left: 0 }}\n          id={`${id}-placeholder`}\n        >\n          {placeholder}\n        </div>\n      )}\n    </div>\n  )\n}\n\nexport default HTMLInput\n","import React, { useState } from 'react'\nimport HTMLInput from 'react-input-with-html'\nimport './style.css'\n\nconst App = () => {\n  const [input, setInput] = useState('')\n\n  const handleSubmit = () => {\n    // submit your own input places\n    console.log('input on submit: ', input)\n  }\n\n  const dynamicHexMod = (value: string) => {\n    return `<span class=\"hex-dot\" style=\"--color: ${value};\">${value}</span>`\n  }\n\n  const modifierArr = [\n    {\n      regexMatch: /#[0-9A-F]{6}/gi,\n      htmlMod: dynamicHexMod\n    },\n    {\n      regexMatch: /\\+/g,\n      htmlMod: `<span style=\"color: #a3a3a3\">+</span>`\n    }\n  ]\n\n  return (\n    <>\n      <h1 className={'title'}>Search for your stuff</h1>\n      <HTMLInput\n        id='input'\n        value={input}\n        placeholder='Search our curated collection'\n        onChange={setInput}\n        onSubmit={handleSubmit}\n        modifierArr={modifierArr}\n        spellCheck={false}\n      />\n    </>\n  )\n}\n\nexport default App\n","import './index.css'\n\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nimport App from './App'\n\nReactDOM.render(<App />, document.getElementById('root'))\n"],"sourceRoot":""}