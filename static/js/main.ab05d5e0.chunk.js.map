{"version":3,"sources":["../../src/utils.tsx","../../src/index.tsx","App.tsx","index.tsx"],"names":["getCaretData","nodes","el","textNodeArr","treeWalker","document","NodeFilter","node","getAllTextnodes","n","position","setCaretPos","html","disabled","onChange","onBlur","onKeyUp","onKeyDown","id","props","useState","caretPos","useEffect","caretData","data","selection","window","range","placeCaret","str","emitChange","e","caretOffset","selected","preCaretRange","getCaretPosition","React","style","whiteSpace","overflow","contentEditable","onInput","dangerouslySetInnerHTML","__html","App","input","setInput","className","ReactDOM","render","getElementById"],"mappings":"uRACO,IAwCMA,EAAe,SAAC,EAAD,KAS1B,IAJA,MAEMC,EAvBuB,SAACC,GAW9B,IAVA,MACMC,EAAN,GAEMC,EAAaC,4BAEjBC,WAFiBD,gBAAnB,GAOQE,EAAOH,EAAf,YAAuCD,UAEvC,SAUcK,CAAd,GAESC,EAAT,EAAgBA,EAAIR,EAApB,OAAkCQ,IAAK,CAErC,KAAIC,EAAWT,eAAXS,QAAwCT,EAAMQ,EAAlD,IAIO,CACLF,EAAON,EAAPM,GACA,MAHAG,GAAYT,eAAZS,OASJ,SAQO,CAAEH,KAAF,EAAcG,SAAUA,IAP7BC,MAEO,CAAEJ,KAAF,EAAcG,UAAW,K,EC3ClB,SAAC,G,IACjBE,S,IACAC,oBAAWA,GAAA,EAEXC,aACAC,WACAC,YACAC,cACAC,OACGC,E,oIAAAA,oF,EAE6BC,oBAAQ,GAAjCC,OAAUV,OAEjBW,qBAAU,WACR,IAAMpB,EAAKG,wBAAX,GACMkB,EAAYvB,EAAaE,EAAImB,EAAnC,GAGIE,EAAJ,MDsCsB,SAACC,GACzB,IAAMC,EAAYC,OAAlB,eACMC,EAAQtB,SAAd,cAOEoB,MAEAD,EAFAC,MAGAD,YAHAC,GAIAD,OAJAC,WAKAD,yBAA8BA,EANhC,WASEG,WAAeH,EAAfG,KAA0BH,EAA1BG,UAEAA,eAEA,IACEF,oBACAA,gBC7DkBG,MACnB,CANHN,IAQA,ID5C4BO,EC4CtBC,EAAa,SAACC,GAClB,IAAM7B,EAAK6B,EAAX,cACMrB,EDzCsB,SAACR,GAC/B,IAAI8B,EAAJ,EAEA,wBAAWN,OAAP,aAA4C,OACxCC,EAAK,UAAGD,OAAH,mCAAGA,aAAd,GACMO,EAAQ,OAAGN,QAAH,IAAGA,OAAH,EAAGA,aAAjB,OACMO,EAAa,OAAGP,QAAH,IAAGA,OAAH,EAAGA,EAAtB,aAGAO,wBAEAA,SAAqBP,EAArBO,aAAyCP,EAAzCO,WAEAF,EAAcE,oBAAdF,EAGF,SCyBmBG,CAAjB,GAEArB,EAASZ,EAATY,WACAH,MAGF,OACEyB,uCACElB,GAAIA,EACJmB,MAAO,CAAEC,WAAF,SAAwBC,SAAU,UACzCC,iBAAkB3B,EAClB4B,QAASX,EACTf,OAAQA,GAAUe,EAClBd,QAASA,GAAWc,EACpBb,UAAWA,GAAaa,EACxBY,wBAAyB,CAAEC,QD7DHd,EC6DyBjB,ED5D9CiB,GAAOA,kCAAd,QCmDA,KCtCae,G,MAXH,WAAO,IAAD,EACUxB,mBAAS,IADnB,mBACTyB,EADS,KACFC,EADE,KAGhB,OACE,oCACE,wBAAIC,UAAW,SAAf,yBACA,kBAAC,EAAD,CAAW7B,GAAG,QAAQN,KAAMiC,EAAO/B,SAAUgC,OCJnDE,IAASC,OAAO,kBAAC,EAAD,MAAS5C,SAAS6C,eAAe,W","file":"static/js/main.ab05d5e0.chunk.js","sourcesContent":["// not sure what this is doing, but should probably sanitize javascript injection\nexport const normalizeHtml = (str: string): string => {\n  return str && str.replace(/&nbsp;|\\u202F|\\u00A0/g, ' ')\n}\n\n// getting current position of caret to set in state as a reference\nexport const getCaretPosition = (el: HTMLDivElement) => {\n  let caretOffset = 0\n\n  if (typeof window.getSelection !== 'undefined') {\n    const range = window.getSelection()?.getRangeAt(0)\n    const selected = range?.toString().length\n    const preCaretRange = range?.cloneRange()\n\n    // @ts-ignore\n    preCaretRange.selectNodeContents(el)\n    // @ts-ignore\n    preCaretRange.setEnd(range.endContainer, range.endOffset)\n    // @ts-ignore\n    caretOffset = preCaretRange.toString().length - selected\n  }\n\n  return caretOffset\n}\n\nexport const getAllTextnodes = (el: HTMLDivElement) => {\n  let node\n  const textNodeArr = []\n\n  const treeWalker = document.createTreeWalker(\n    el,\n    NodeFilter.SHOW_TEXT,\n    null,\n    false\n  )\n\n  while ((node = treeWalker.nextNode())) textNodeArr.push(node)\n\n  return textNodeArr\n}\n\nexport const getCaretData = (\n  el: HTMLDivElement,\n  position: number,\n  setCaretPos: (arg: number) => void\n) => {\n  let node\n\n  const nodes = getAllTextnodes(el)\n\n  for (var n = 0; n < nodes.length; n++) {\n    // @ts-ignore\n    if (position > nodes[n].nodeValue.length && nodes[n + 1]) {\n      // remove amount from the position, go to next node\n      // @ts-ignore\n      position -= nodes[n].nodeValue.length\n    } else {\n      node = nodes[n]\n      break\n    }\n  }\n\n  // resets node and position settings if all html input is cleared\n\n  if (!node) {\n    setCaretPos(-1)\n\n    return { node: node, position: -1 }\n  }\n\n  // gives current position\n\n  return { node: node, position: position }\n}\n\ntype NodeData = {\n  node: Node\n  position: number\n}\n\nexport const placeCaret = (data: NodeData) => {\n  const selection = window.getSelection()\n  const range = document.createRange()\n\n  // programatic html generation can throws off the caret pos.\n\n  // this protects against placing caret where it can't go\n\n  const canPlaceCaret =\n    selection &&\n    data &&\n    data.node &&\n    data.position >= 0 &&\n    data.node.nodeValue &&\n    data.node.nodeValue.length >= data.position\n\n  if (canPlaceCaret) {\n    range.setStart(data.node, data.position)\n\n    range.collapse(true)\n\n    if (selection) {\n      selection.removeAllRanges()\n      selection.addRange(range)\n    }\n  }\n}\n","/**\n * an input element that can display programatic html but only takes string input\n */\n\nimport React, { useEffect, useState } from 'react'\nimport {\n  getCaretData,\n  placeCaret,\n  getCaretPosition,\n  normalizeHtml\n} from './utils'\n\ntype Props = {\n  id: string\n  html: string // your display of the html\n  onChange: (arg1: string) => void // your `setInput` string hook;\n  disabled?: boolean\n  className?: string\n  onBlur?: any\n  onKeyUp?: any\n  onKeyDown?: any\n  spellCheck?: boolean\n}\n\nconst HTMLInput = ({\n  html,\n  disabled = false,\n  spellCheck = true,\n  onChange,\n  onBlur,\n  onKeyUp,\n  onKeyDown,\n  id,\n  ...props\n}: Props) => {\n  const [caretPos, setCaretPos] = useState(-1)\n\n  useEffect(() => {\n    const el = document.getElementById(id) as HTMLDivElement\n    const caretData = getCaretData(el, caretPos, setCaretPos)\n\n    // only place caret if there is somewhere for it to go\n    if (caretData.node) placeCaret(caretData)\n  }, [html])\n\n  const emitChange = (e: any) => {\n    const el = e.currentTarget\n    const position = getCaretPosition(el)\n\n    onChange(el.innerText)\n    setCaretPos(position)\n  }\n\n  return (\n    <div\n      id={id}\n      style={{ whiteSpace: 'nowrap', overflow: 'hidden' }}\n      contentEditable={!disabled}\n      onInput={emitChange}\n      onBlur={onBlur || emitChange}\n      onKeyUp={onKeyUp || emitChange}\n      onKeyDown={onKeyDown || emitChange}\n      dangerouslySetInnerHTML={{ __html: normalizeHtml(html) }}\n      {...props}\n    />\n  )\n}\n\nexport default HTMLInput\n","import React, { useState } from 'react'\nimport HTMLInput from 'react-input-with-html'\nimport './style.css'\n\nconst App = () => {\n  const [input, setInput] = useState('')\n\n  return (\n    <>\n      <h1 className={'title'}>Search for your stuff</h1>\n      <HTMLInput id='input' html={input} onChange={setInput} />\n    </>\n  )\n}\n\nexport default App\n","import './index.css'\n\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nimport App from './App'\n\nReactDOM.render(<App />, document.getElementById('root'))\n"],"sourceRoot":""}