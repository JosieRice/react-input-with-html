{"version":3,"sources":["../../src/utils.tsx","../../src/index.tsx","App.tsx","index.tsx"],"names":["getCaretData","nodes","el","textNodeArr","treeWalker","document","NodeFilter","node","getAllTextnodes","n","position","setCaretPos","id","value","disabled","spellCheck","onChange","modifierArr","onSubmit","onBlur","onKeyUp","onKeyDown","hexDot","style","highlightThis","props","useState","inputWithHTML","setInputWithHTML","caretPos","useEffect","caretData","data","selection","window","range","placeCaret","inputDisplay","buildStyledString","highlighted","mutableInput","clone","re","RegExp","highlightedString","str","emitChange","e","enter","caretOffset","selected","preCaretRange","getCaretPosition","mutableModifierArr","regexMatch","htmlMod","styles","match","modifier","mutableModifier","arr","uniqueArr","self","correctModifier","v","React","className","contentEditable","onInput","dangerouslySetInnerHTML","__html","App","inputHero","setInputHero","inputNav","setInputNav","setHighlightThis","handleSubmit","alert","enable","width","height","top","left","textAlign","margin","onClick","onMouseEnter","onMouseLeave","ReactDOM","render","getElementById"],"mappings":"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","file":"static/js/main.80469d39.chunk.js","sourcesContent":["// not sure what this is doing, but should probably sanitize javascript injection\nexport const normalizeHtml = (str: string): string => {\n  return str && str.replace(/&nbsp;|\\u202F|\\u00A0/g, ' ')\n}\n\n// getting current position of caret to set in state as a reference\nexport const getCaretPosition = (el: HTMLDivElement | null) => {\n  let caretOffset = 0\n\n  if (!el) return\n\n  if (typeof window.getSelection !== 'undefined') {\n    const range = window.getSelection()?.getRangeAt(0)\n    const selected = range?.toString().length\n    const preCaretRange = range?.cloneRange()\n\n    // @ts-ignore\n    preCaretRange.selectNodeContents(el)\n    // @ts-ignore\n    preCaretRange.setEnd(range.endContainer, range.endOffset)\n    // @ts-ignore\n    caretOffset = preCaretRange.toString().length - selected\n  }\n\n  return caretOffset\n}\n\nexport const getAllTextnodes = (el: HTMLDivElement) => {\n  let node\n  const textNodeArr = []\n\n  const treeWalker = document.createTreeWalker(\n    el,\n    NodeFilter.SHOW_TEXT,\n    null,\n    false\n  )\n\n  while ((node = treeWalker.nextNode())) textNodeArr.push(node)\n\n  return textNodeArr\n}\n\nexport const getCaretData = (\n  el: HTMLDivElement,\n  position: number,\n  setCaretPos: (arg: number) => void\n) => {\n  let node\n\n  const nodes = getAllTextnodes(el)\n\n  for (var n = 0; n < nodes.length; n++) {\n    // @ts-ignore\n    if (position > nodes[n].nodeValue.length && nodes[n + 1]) {\n      // remove amount from the position, go to next node\n      // @ts-ignore\n      position -= nodes[n].nodeValue.length\n    } else {\n      node = nodes[n]\n      break\n    }\n  }\n\n  // resets node and position settings if all html input is cleared\n\n  if (!node) {\n    setCaretPos(-1)\n\n    return { node: node, position: -1 }\n  }\n\n  // gives current position\n\n  return { node: node, position: position }\n}\n\ntype NodeData = {\n  node: Node\n  position: number\n}\n\nexport const placeCaret = (data: NodeData) => {\n  const selection = window.getSelection()\n  const range = document.createRange()\n\n  // programatic html generation can throws off the caret pos.\n\n  // this protects against placing caret where it can't go\n\n  const canPlaceCaret =\n    selection &&\n    data &&\n    data.node &&\n    data.position >= 0 &&\n    data.node.nodeValue &&\n    data.node.nodeValue.length >= data.position\n\n  if (canPlaceCaret) {\n    range.setStart(data.node, data.position)\n\n    range.collapse(true)\n\n    if (selection) {\n      selection.removeAllRanges()\n      selection.addRange(range)\n    }\n  }\n}\n","/**\n * an input element that can display programatic html but only takes string input\n * with a built in hex dot option\n */\n\nimport { clone } from 'lodash'\nimport React, { useEffect, useState } from 'react'\nimport styles from './styles.module.css'\nimport {\n  getCaretData,\n  getCaretPosition,\n  normalizeHtml,\n  placeCaret\n} from './utils'\n\ntype ModifierObj = {\n  regexMatch: RegExp\n  htmlMod: string | Function // if it's a function than it's matching many different strings possibly\n  match?: boolean\n}\n\ntype HexDotObj = {\n  enable: boolean\n  style: {\n    width: string\n    height: string\n    top: string\n    left: string\n  }\n}\n\ntype Props = {\n  id: string\n  value: string\n  modifierArr: ModifierObj[]\n  onChange: (arg1: string) => void // your `setInput` string hook;\n  highlightThis?: string | boolean\n  onSubmit?: Function\n  disabled?: boolean\n  className?: string\n  onBlur?: any\n  onKeyUp?: any\n  onKeyDown?: any\n  spellCheck?: boolean\n  hexDot?: HexDotObj\n  style?: any\n}\n\nconst HTMLInput = ({\n  id,\n  value,\n  disabled = false,\n  spellCheck = true,\n  onChange,\n  modifierArr,\n  onSubmit,\n  onBlur,\n  onKeyUp,\n  onKeyDown,\n  hexDot,\n  style,\n  highlightThis,\n  ...props\n}: Props) => {\n  const [inputWithHTML, setInputWithHTML] = useState('')\n  const [caretPos, setCaretPos] = useState(-1)\n\n  useEffect(() => {\n    const el = document.getElementById(id) as HTMLDivElement\n    const caretData = getCaretData(el, caretPos, setCaretPos)\n\n    // only place caret if there is somewhere for it to go\n    if (caretData.node) placeCaret(caretData)\n  }, [inputWithHTML])\n\n  useEffect(() => {\n    const highlightedString = (inputDisplay: string): string => {\n      let mutableInput = clone(inputDisplay)\n      if (highlightThis && typeof highlightThis === 'string') {\n        const re = new RegExp(\n          `${highlightThis\n            // handle all of the special characters that need to be escaped\n            .replace('*', '\\\\*')\n            .replace('[', '\\\\[')\n            .replace('^', '\\\\^')\n            .replace('$', '\\\\$')\n            .replace('.', '\\\\.')\n            .replace('|', '\\\\|')\n            .replace('?', '\\\\?')\n            .replace('+', '\\\\+')\n            .replace('(', '\\\\(')\n            .replace(')', '\\\\)')}(?!\">)`,\n          'gi'\n        )\n\n        mutableInput = mutableInput.replace(\n          re,\n          `<span style=\"background-color: #b4ffc4\">${highlightThis}</span>`\n        )\n      } else if (highlightThis && typeof highlightThis === 'boolean') {\n        mutableInput = `<span style=\"background-color: #b4ffc4\">${inputDisplay}</span>`\n      }\n      return mutableInput\n    }\n\n    const inputDisplay = buildStyledString(value, hexDot)\n    if (highlightThis) {\n      const highlighted = highlightedString(inputDisplay)\n      setInputWithHTML(highlighted)\n    } else {\n      setInputWithHTML(inputDisplay)\n    }\n  }, [highlightThis])\n\n  useEffect(() => {\n    if (value) {\n      const inputDisplay = buildStyledString(value, hexDot)\n      setInputWithHTML(inputDisplay)\n    } else if (!value) {\n      setInputWithHTML('')\n    }\n  }, [value])\n\n  const emitChange = (e: any) => {\n    // handle enter and call onSubmit if it was give\n    const enter = e.keyCode === 13\n    if (enter && onSubmit) {\n      e.preventDefault()\n      onSubmit()\n      return\n    }\n    if (enter) {\n      e.preventDefault()\n      return\n    }\n\n    const el = e.currentTarget\n    const position = getCaretPosition(el)\n\n    onChange(el.innerText)\n    setCaretPos(position || -1)\n  }\n\n  const buildStyledString = (\n    value: string,\n    hexDot: HexDotObj | undefined\n  ): string => {\n    let mutableInput = clone(value)\n\n    const mutableModifierArr = clone(modifierArr)\n\n    if (hexDot) {\n      const dynamicHexMod = (value: string, hexDot: HexDotObj): any => {\n        return `<span class=\"${styles.hexdot}\" \n          style=\"\n            --width: ${hexDot.style.width}; \n            --height: ${hexDot.style.height}; \n            --top: ${hexDot.style.top}; \n            --left: ${hexDot.style.left};\n            --border: ${value === '#ffffff' ? '1px solid #A3A3A3' : 'unset'};\n            --color: ${value}\">${value}</span>`\n      }\n\n      const hexDot = {\n        // only matches hex codes that aren't in style (followed by \")\n        regexMatch: /#[0-9A-F]{6}(?!\">)/gi,\n        htmlMod: dynamicHexMod\n      }\n      mutableModifierArr.push(hexDot)\n    }\n\n    // adds match true or false to modifierObj\n    const mutableModifier = mutableModifierArr.map((modifier) => {\n      const match = modifier.regexMatch.test(value)\n      modifier.match = match\n      return modifier\n    })\n\n    // for each match, find every instance and run the modification\n    mutableModifier.forEach((modifier) => {\n      if (modifier.match) {\n        const arr = mutableInput?.match(modifier.regexMatch)\n        const unique = (value: any, index: any, self: any) => {\n          return self.indexOf(value) === index\n        }\n        const uniqueArr = arr?.filter(unique)\n\n        const modifyAll = () => {\n          const value = uniqueArr?.forEach((v) => {\n            const correctModifier =\n              typeof modifier.htmlMod === 'string'\n                ? modifier.htmlMod\n                : modifier.htmlMod(v, hexDot)\n\n            // function htmlMods can match many different strings and need special treatment\n            if (typeof modifier.htmlMod === 'function') {\n              const re = new RegExp(v, 'g')\n              mutableInput = mutableInput?.replace(re, correctModifier)\n            } else {\n              mutableInput = mutableInput?.replace(\n                modifier.regexMatch,\n                correctModifier\n              )\n            }\n          })\n          return value\n        }\n\n        modifyAll()\n      }\n    })\n\n    // clears out any new lines\n    const newLineRegex = /\\r?\\n|\\r/g\n    mutableInput.replace(newLineRegex, '')\n\n    return mutableInput\n  }\n\n  return (\n    <div\n      id={id}\n      // respects any spaces and styles close to a native input\n      className={styles.input}\n      contentEditable={!disabled}\n      onInput={emitChange}\n      onBlur={onBlur || emitChange}\n      onKeyUp={onKeyUp || emitChange}\n      onKeyDown={onKeyDown || emitChange}\n      dangerouslySetInnerHTML={{ __html: normalizeHtml(inputWithHTML) }}\n      spellCheck={spellCheck}\n      style={style}\n      {...props}\n    />\n  )\n}\n\nexport default HTMLInput\n","import React, { useState } from 'react'\nimport HTMLInput from 'react-input-with-html'\nimport 'react-input-with-html/dist/index.css'\nimport './style.css'\n\nconst App = () => {\n  const [inputHero, setInputHero] = useState('')\n  const [inputNav, setInputNav] = useState('')\n  const [highlightThis, setHighlightThis] = useState<string | boolean>('')\n\n  const handleSubmit = () => {\n    // submit your own input places\n    alert(`You just called submit can have this in state: ${inputHero}`)\n  }\n\n  const modifierArr = [\n    {\n      regexMatch: /\\+/g,\n      htmlMod: `<span style=\"color: #a3a3a3\">+</span>`\n    }\n  ]\n\n  const hexDotHero = {\n    enable: true,\n    style: {\n      width: '24px',\n      height: '24px',\n      top: '4px',\n      left: '4px'\n    }\n  }\n\n  const hexDotNav = {\n    enable: true,\n    style: {\n      width: '11px',\n      height: '11px',\n      top: '2px',\n      left: '2px'\n    }\n  }\n\n  return (\n    <>\n      <h1 className={'title'}>Hero Search From Stocksy</h1>\n      <HTMLInput\n        id='input'\n        value={inputHero}\n        onChange={setInputHero}\n        onSubmit={handleSubmit}\n        modifierArr={modifierArr}\n        spellCheck={false}\n        hexDot={hexDotHero}\n        highlightThis={highlightThis}\n      />\n\n      <div style={{ textAlign: 'center', margin: 12 }}>\n        <button\n          onClick={() => setInputHero('#E33CC7')}\n          onMouseEnter={() => setHighlightThis('#E33CC7')}\n          onMouseLeave={() => setHighlightThis('')}\n        >\n          #E33CC7\n        </button>\n      </div>\n\n      <div style={{ textAlign: 'center', margin: 12 }}>\n        <button\n          onClick={() => setInputHero('*')}\n          onMouseEnter={() => setHighlightThis('*')}\n          onMouseLeave={() => setHighlightThis('')}\n        >\n          *\n        </button>\n      </div>\n\n      <div style={{ textAlign: 'center', margin: 12 }}>\n        <button\n          onClick={() => setInputHero('')}\n          onMouseEnter={() => setHighlightThis(true)}\n          onMouseLeave={() => setHighlightThis('')}\n        >\n          Delete\n        </button>\n      </div>\n\n      <h1 className={'title'}>Nav Search From Stocksy</h1>\n      <HTMLInput\n        id='input-nav'\n        value={inputNav}\n        onChange={setInputNav}\n        onSubmit={handleSubmit}\n        modifierArr={modifierArr}\n        spellCheck={false}\n        hexDot={hexDotNav}\n      />\n    </>\n  )\n}\n\nexport default App\n","import './index.css'\n\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nimport App from './App'\n\nReactDOM.render(<App />, document.getElementById('root'))\n"],"sourceRoot":""}